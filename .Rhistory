# update this to use diff() function
vp_m <- D(expression(v_m(a)), name = "a")
#### D and D.tilde ####
# Need to calc v' (vp; v prime)
# update this to use diff() function
vp_m <- D(expression(function(a) {v_m(a)}), name = "a")
#### D and D.tilde ####
# Need to calc v' (vp; v prime)
# update this to use diff() function
vp_m <- D(call(v_m(a)), name = "a")
#### D and D.tilde ####
# Need to calc v' (vp; v prime)
# update this to use diff() function
vp_m <- D(call(v_m()), name = "a")
#### D and D.tilde ####
# Need to calc v' (vp; v prime)
# update this to use diff() function
vp_m <- D(call(v_m()), name = "v")
#### D and D.tilde ####
# Need to calc v' (vp; v prime)
# update this to use diff() function
vp_m <- D(call(v_m(v)), name = "v")
D(v_m(76))
D(v_m(76), name = "v")
D(v_m(v=76), name = "v")
D(v_m(v=70), name = "v")
deriv(~v_m(x), "x")
deriv(y~v_m(x), "x")
deriv(y~v_m(x), "y")
library(numDeriv)
?numDeric
?numDeriv
?grad
grad(v_m)
grad(v_m, 70)
grad(v_m, 75)
grad(v_m, 70.1)
library(numDeriv)
D <- ((BETA - R)^2 - sigma.hat.sq_m/Q.tilde)*grad(v_m, BETA) -
((ALPHA - mu.hat_m)^2-sigma.hat.sq_m/Q.tilde)*grad(v_m, ALPHA + DELTA) -
2*(BETA - R)*v_w(BETA) + 2(ALPHA - mu.hat_m)*v_w(ALPHA + DELTA) + 2Q
D <- ((BETA - R)^2 - sigma.hat.sq_m/Q.tilde)*grad(v_m, BETA) -
((ALPHA - mu.hat_m)^2-sigma.hat.sq_m/Q.tilde)*grad(v_m, ALPHA + DELTA) -
2*(BETA - R)*v_w(BETA) + 2(ALPHA - mu.hat_m)*v_w(ALPHA + DELTA) + 2*Q
rm(list=ls())
gc()
m.sim <- readxl::read_excel("men-sim-file.xls", col_names = F) %>%
rename(age = "...1", v = "...2") %>%
mutate(n = 1)
f.sim <- readxl::read_excel("women-sim-file.xls", col_names = F) %>%
rename(age = "...1", v = "...2") %>%
mutate(n = 1)
m.sim
f.sim
ggplot() +
geom_line(data = m.sim, aes(x = age, y = v), color = "blue") +
geom_line(data = f.sim, aes(x = age, y = v), color = "red")
##### Step 0: Normalizing densities #####
# I made this mistake before by not normalizing.
m.sim$v <- m.sim$v/sum(m.sim$v)
f.sim$v <- f.sim$v/sum(f.sim$v)
# ALPHA <- min(min(m.sim$age), min(f.sim$age))
# BETA <- max(max(m.sim$age), max(f.sim$age))
ALPHA <- 70
BETA <- 80
# m.sim <- m.sim %>% filter(age >= ALPHA, age <= BETA)
# f.sim <- f.sim %>% filter(age >= ALPHA, age <= BETA)
mu_m <- weighted.mean(m.sim$age, m.sim$v)
mu_f <- weighted.mean(f.sim$age, f.sim$v)
rm(list=ls())
gc()
m.sim <- readxl::read_excel("men-sim-file.xls", col_names = F) %>%
rename(age = "...1", v = "...2") %>%
mutate(n = 1)
f.sim <- readxl::read_excel("women-sim-file.xls", col_names = F) %>%
rename(age = "...1", v = "...2") %>%
mutate(n = 1)
m.sim
f.sim
ggplot() +
geom_line(data = m.sim, aes(x = age, y = v), color = "blue") +
geom_line(data = f.sim, aes(x = age, y = v), color = "red")
##### Step 0: Normalizing densities #####
# I made this mistake before by not normalizing.
m.sim$v <- m.sim$v/sum(m.sim$v)
f.sim$v <- f.sim$v/sum(f.sim$v)
#### Convert to continuous time functions #
v_w <- approxfun(m.sim$age, m.sim$v)
v_m <- approxfun(f.sim$age, f.sim$v)
# ALPHA <- min(min(m.sim$age), min(f.sim$age))
# BETA <- max(max(m.sim$age), max(f.sim$age))
ALPHA <- 70
BETA <- 80
m.sim <- m.sim %>% filter(age >= ALPHA, age <= BETA)
f.sim <- f.sim %>% filter(age >= ALPHA, age <= BETA)
mu_m <- weighted.mean(m.sim$age, m.sim$v)
mu_f <- weighted.mean(f.sim$age, f.sim$v)
DELTA <- round(mu_f - mu_m)
if(is.na(v_w(ALPHA +DELTA))) stop("ALPHA + DELTA falls outside of range")
if(is.na(v_w(BETA - DELTA))) stop("BETA - DELTA falls outside of range")
if(is.na(v_m(ALPHA +DELTA))) stop("ALPHA + DELTA falls outside of range")
if(is.na(v_m(BETA - DELTA))) stop("BETA - DELTA falls outside of range")
mu.hat_w <- integrate(function(a) {a * v_m(a)}, ALPHA+DELTA, BETA)$value
mu.hat_m <- integrate(function(a) {a * v_w(a)}, ALPHA, BETA-DELTA)$value
sigma.hat.sq_w <- integrate(function(a){(a - mu.hat_w)^2 * v_w(a)},ALPHA+DELTA, BETA)$value
sigma.hat.sq_m <- integrate(function(a){(a - mu.hat_m)^2 * v_m(a)},ALPHA, BETA-DELTA)$value
Q <- integrate(v_w,ALPHA + DELTA, BETA)$value
Q.tilde <- integrate(v_m, ALPHA, BETA - DELTA)$value
R <- mu.hat_w + DELTA
R.tilde <- mu.hat_m - DELTA
N <- ((BETA - R)^2 - sigma.hat.sq_m/Q.tilde)*v_w(BETA) -
((ALPHA - mu.hat_m)^2 - sigma.hat.sq_m/Q.tilde)*v_w(ALPHA + DELTA) -
2*mu.hat_w+2*R*Q
N.tilde <- ((BETA - mu.hat_w)^2 - sigma.hat.sq_w/Q)*v_m(BETA - DELTA) -
((ALPHA - R.tilde)^2 - sigma.hat.sq_w/Q)*v_m(ALPHA) -
2*mu.hat_m + 2*R.tilde*Q.tilde
f_D <- function(beta, R, sigma.hat.sq_m, Q.tilde,
df, alpha, mu.hat_m, delta, Q){
a1 <- ((beta - R)^2 - sigma.hat.sq_m/Q.tilde) * (df %>% filter(age == beta) %>% pull("vp"))
a2 <- ((alpha - mu.hat_m)^2 - sigma.hat.sq_m/Q.tilde) * (df %>% filter(age == round(alpha + delta)) %>% pull("vp"))
a3 <- 2*(beta - R)*(df %>% filter(age == beta) %>% pull("v"))
a4 <- 2*(alpha - mu.hat_m)*(df %>% filter(age == round(alpha + delta)) %>% pull("v")) + 2*Q
return(a1 - a2 - a3 + a4)
}
D <- f_D(BETA, R, sigma.hat.sq_m, Q.tilde, m.sim, ALPHA, mu.hat_m, DELTA, Q)
D <- ((BETA - R)^2 - sigma.hat.sq_m/Q.tilde)*grad(v_m, BETA) -
((ALPHA - mu.hat_m)^2-sigma.hat.sq_m/Q.tilde)*grad(v_m, ALPHA + DELTA) -
2*(BETA - R)*v_w(BETA) + 2(ALPHA - mu.hat_m)*v_w(ALPHA + DELTA) + 2*Q
f_D.tilde <- function(beta, mu.hat_w, sigma.hat.sq_w, Q, df, alpha, R.tilde, Q.tilde, delta) {
a1 <- ((beta - mu.hat_w)^2 - sigma.hat.sq_w/Q) * (df %>% filter(age == round(beta - delta)) %>% pull("vp"))
a2 <- ((alpha - R.tilde)^2 - sigma.hat.sq_w/Q) * (df %>% filter(age == alpha) %>% pull("vp"))
a3 <- 2 * (beta - mu.hat_w) * (df %>% filter(age == round(beta - delta)) %>% pull("v"))
a4 <- 2*(alpha - R.tilde) * (df %>% filter(age == alpha) %>% pull("v")) + 2*Q.tilde
return(a1 - a2 - a3 + a4)
}
D.tilde <- f_D.tilde(BETA, mu.hat_w, sigma.hat.sq_w, Q, m.sim, ALPHA, R.tilde, Q.tilde, DELTA)
D <- ((BETA - R)^2 - sigma.hat.sq_m/Q.tilde)*grad(v_m, BETA) -
((ALPHA - mu.hat_m)^2-sigma.hat.sq_m/Q.tilde)*grad(v_m, ALPHA + DELTA) -
2*(BETA - R)*v_w(BETA) + 2(ALPHA - mu.hat_m)*v_w(ALPHA + DELTA) + 2*Q
grad(v_m,BETA)
D <- ((BETA - R)^2 - sigma.hat.sq_m/Q.tilde)*grad(v_m, BETA) -
((ALPHA - mu.hat_m)^2-sigma.hat.sq_m/Q.tilde)*grad(v_m, ALPHA + DELTA) -
2*(BETA - R)*v_w(BETA) + 2*(ALPHA - mu.hat_m)*v_w(ALPHA + DELTA) + 2*Q
D
D.tilde <- ((BETA - mu.hat_w)^2 - sigma.hat.sq_w/Q)*grad(v_m, BETA - DELTA)-
((ALPHA - R.tilde)^2 - sigma.hat.sq_w/Q)*grad(v_m, ALPHA) -
2*(BETA - mu.hat_w)*v_m(BETA - DELTA) + 2(ALPHA - R.tilde) * v_m(ALPHA)+2*Q.tilde
((BETA - mu.hat_w)^2 - sigma.hat.sq_w/Q)*grad(v_m, BETA - DELTA)
((ALPHA - R.tilde)^2 - sigma.hat.sq_w/Q)*grad(v_m, ALPHA)
2*(BETA - mu.hat_w)*v_m(BETA - DELTA)
D.tilde <- ((BETA - mu.hat_w)^2 - sigma.hat.sq_w/Q)*grad(v_m, BETA - DELTA)-
((ALPHA - R.tilde)^2 - sigma.hat.sq_w/Q)*grad(v_m, ALPHA) -
2*(BETA - mu.hat_w)*v_m(BETA - DELTA) + 2*(ALPHA - R.tilde) * v_m(ALPHA)+2*Q.tilde
D.tilde
rm(list=ls())
setwd("~/S-timators")
rm(list=ls())
gc()
m.sim <- readxl::read_excel("men-sim-file.xls", col_names = F) %>%
rename(age = "...1", v = "...2") %>%
mutate(n = 1)
f.sim <- readxl::read_excel("women-sim-file.xls", col_names = F) %>%
rename(age = "...1", v = "...2") %>%
mutate(n = 1)
m.sim
f.sim
ggplot() +
geom_line(data = m.sim, aes(x = age, y = v), color = "blue") +
geom_line(data = f.sim, aes(x = age, y = v), color = "red")
##### Step 0: Normalizing densities #####
# I made this mistake before by not normalizing.
m.sim$v <- m.sim$v/sum(m.sim$v)
f.sim$v <- f.sim$v/sum(f.sim$v)
#### Convert to continuous time functions #
v_w <- approxfun(m.sim$age, m.sim$v)
v_m <- approxfun(f.sim$age, f.sim$v)
# ALPHA <- min(min(m.sim$age), min(f.sim$age))
# BETA <- max(max(m.sim$age), max(f.sim$age))
ALPHA <- 70
BETA <- 80
m.sim <- m.sim %>% filter(age >= ALPHA, age <= BETA)
f.sim <- f.sim %>% filter(age >= ALPHA, age <= BETA)
mu_m <- weighted.mean(m.sim$age, m.sim$v)
mu_f <- weighted.mean(f.sim$age, f.sim$v)
DELTA <- round(mu_f - mu_m)
stimator <- function(DELTA, ALPHA, BETA, v_w, v_m){
if(is.na(v_w(ALPHA +DELTA))) stop("ALPHA + DELTA falls outside of range")
if(is.na(v_w(BETA - DELTA))) stop("BETA - DELTA falls outside of range")
if(is.na(v_m(ALPHA +DELTA))) stop("ALPHA + DELTA falls outside of range")
if(is.na(v_m(BETA - DELTA))) stop("BETA - DELTA falls outside of range")
#### mu ####
mu.hat_w <- integrate(function(a) {a * v_m(a)}, ALPHA+DELTA, BETA)$value
mu.hat_m <- integrate(function(a) {a * v_w(a)}, ALPHA, BETA-DELTA)$value
# Quick sanity check:
# ggplot() +
#   geom_line(data = m.sim, aes(x = age, y = v), color = "blue") +
#   geom_line(data = f.sim, aes(x = age, y = v), color = "red")  +
#   geom_vline(xintercept = ALPHA + DELTA) +
#   geom_vline(xintercept = BETA - DELTA) +
#   geom_vline(xintercept = mu_m, color = "blue") +
#   geom_vline(xintercept = mu_f, color = "red")
#### sigma.hat.sq ####
sigma.hat.sq_w <- integrate(function(a){(a - mu.hat_w)^2 * v_w(a)},ALPHA+DELTA, BETA)$value
sigma.hat.sq_m <- integrate(function(a){(a - mu.hat_m)^2 * v_m(a)},ALPHA, BETA-DELTA)$value
#### Q and Q.tilde ####
Q <- integrate(v_w,ALPHA + DELTA, BETA)$value
Q.tilde <- integrate(v_m, ALPHA, BETA - DELTA)$value
#### R and R.tilde ####
R <- mu.hat_w + DELTA
R.tilde <- mu.hat_m - DELTA
#### N and N.tilde ####
N <- ((BETA - R)^2 - sigma.hat.sq_m/Q.tilde)*v_w(BETA) -
((ALPHA - mu.hat_m)^2 - sigma.hat.sq_m/Q.tilde)*v_w(ALPHA + DELTA) -
2*mu.hat_w+2*R*Q
N.tilde <- ((BETA - mu.hat_w)^2 - sigma.hat.sq_w/Q)*v_m(BETA - DELTA) -
((ALPHA - R.tilde)^2 - sigma.hat.sq_w/Q)*v_m(ALPHA) -
2*mu.hat_m + 2*R.tilde*Q.tilde
#### D and D.tilde ####
# Need to calc v' (vp; v prime)
# Doing with with numDeriv package
# ex: grad(v_m, 70.2)
D <- ((BETA - R)^2 - sigma.hat.sq_m/Q.tilde)*grad(v_m, BETA) -
((ALPHA - mu.hat_m)^2-sigma.hat.sq_m/Q.tilde)*grad(v_m, ALPHA + DELTA) -
2*(BETA - R)*v_w(BETA) + 2*(ALPHA - mu.hat_m)*v_w(ALPHA + DELTA) + 2*Q
D.tilde <- ((BETA - mu.hat_w)^2 - sigma.hat.sq_w/Q)*grad(v_m, BETA - DELTA)-
((ALPHA - R.tilde)^2 - sigma.hat.sq_w/Q)*grad(v_m, ALPHA) -
2*(BETA - mu.hat_w)*v_m(BETA - DELTA) + 2*(ALPHA - R.tilde) * v_m(ALPHA)+2*Q.tilde
ret <- list("ALPHA" = ALPHA,
"BETA" = BETA,
"DELTA" = DELTA,
"D" = D,
"D.tilde" = D.tilde,
"mu_f" = mu_f,
"mu_m" = mu_m,
"mu.hat_m" = mu.hat_m,
"mu.hat_w" = mu.hat_w,
"N" = N,
"N.tilde" = N.tilde,
"Q" = Q,
"Q.tilde" = Q.tilde,
"R" = R,
"R.tilde" = R.tilde,
"sigma.hat.sq_m" = sigma.hat.sq_m,
"sigma.hat.sq_w" = sigma.hat.sq_w)
return(ret)
}
ret <- stimator(DELTA, ALPHA, BETA, f.sim, m.sim)
ret <- stimator(DELTA, ALPHA, BETA, v_w, v_m)
#### The Formulae  ####
#### Estimator 1 ####
f_e1 <- function(delta = DELTA,
N = N,
D = D,
sigma.hat.sq_w = sigma.hat.sq_w,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_w = mu.hat_w,
Q = Q,
Q.tilde = Q.tilde,
R = R) {
a1 <- delta - N/D
a2 <- N^2 - 2*D*(sigma.hat.sq_w + 2*mu.hat_w^2 - Q*mu.hat_w^2 - 2*R*mu.hat_w +
Q*R^2 -  Q/Q.tilde*sigma.hat.sq_m)
return(a1 - (sqrt(a2)/D))
}
e1 <- with(ret, f_e1(delta = DELTA,
N = N,
D = D,
sigma.hat.sq_w = sigma.hat.sq_w,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_w = mu.hat_w,
Q = Q,
Q.tilde = Q.tilde,
R = R) )
print(e1)
#### Estimator 2 ####
f_e2 <- function(delta = DELTA,
N.tilde = N.tilde,
D.tilde = D.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_m = mu.hat_m,
Q.tilde = Q.tilde,
R.tilde = R.tilde,
Q = Q,
sigma.hat.sq_w = sigma.hat.sq_w) {
a1 <- delta + N.tilde/D.tilde
a2 <-  N.tilde^2 - 2*D.tilde * (sigma.hat.sq_m + 2*mu.hat_m^2 -
Q.tilde*mu.hat_m^2 - 2*R.tilde*mu.hat_m +
Q.tilde * R.tilde^2 - Q.tilde/Q*sigma.hat.sq_w)
return(a1 + sqrt(a2)/D.tilde)
}
e2 <- with(ret, f_e2(delta = DELTA,
N.tilde = N.tilde,
D.tilde = D.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_m = mu.hat_m,
Q.tilde = Q.tilde,
R.tilde = R.tilde,
Q = Q,
sigma.hat.sq_w = sigma.hat.sq_w))
print(e2)
f_e3 <- function(delta = DELTA,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N) {
a1 <- sigma.hat.sq_w + 2*mu.hat_w^2 - Q.tilde*mu.hat_w^2 - 2*R*mu.hat_w +
Q.tilde*R^2 - Q/Q.tilde*sigma.hat.sq_m
return(delta - a1/N)
}
e3 <- with(ret, f_e3(delta = DELTA,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N))
print(e3)
f_e4 <- function(delta = DELTA,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_m= mu.hat_m,
Q.tilde = Q.tilde,
R.tilde = R.tilde,
Q = Q,
sigma.hat.sq_w = sigma.hat.sq_w,
N.tilde = N.tilde) {
a1 <- sigma.hat.sq_m + 2*mu.hat_m^2 - Q.tilde*mu.hat_m^2 - 2*R.tilde*mu.hat_m +
Q.tilde * R.tilde^2 - Q.tilde/Q*sigma.hat.sq_w
return(delta + a1/N.tilde)
}
e4 <- with(ret, f_e4(delta = DELTA,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_m= mu.hat_m,
Q.tilde = Q.tilde,
R.tilde = R.tilde,
Q = Q,
sigma.hat.sq_w = sigma.hat.sq_w,
N.tilde = N.tilde))
print(e4)
n <- 10
iteration_df <- data.frame(matrix(0, n, 4))
colnames(iteration_df) <- c("e1", "e2", "e3", "e4")
# e3
iteration_df[1, "e3"] <- e3
for (i in 2:n) {
ret <- stimator(DELTA = e3, ALPHA, BETA, f.sim, m.sim)
e3 <- with(ret, f_e3(delta = e3,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N))
iteration_df[i, "e3"] <- e3
}
?stimator
for (i in 2:n) {
ret <- stimator(DELTA = e3, ALPHA, BETA, v_w, v_m)
e3 <- with(ret, f_e3(delta = e3,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N))
iteration_df[i, "e3"] <- e3
}
DELTA
for (i in 2:n) {
ret <- stimator(DELTA = e3, ALPHA, BETA, v_m, v_w)
e3 <- with(ret, f_e3(delta = e3,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N))
iteration_df[i, "e3"] <- e3
}
ret <- stimator(DELTA, ALPHA, BETA, v_m, v_w)
#### The Formulae  ####
#### Estimator 1 ####
f_e1 <- function(delta = DELTA,
N = N,
D = D,
sigma.hat.sq_w = sigma.hat.sq_w,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_w = mu.hat_w,
Q = Q,
Q.tilde = Q.tilde,
R = R) {
a1 <- delta - N/D
a2 <- N^2 - 2*D*(sigma.hat.sq_w + 2*mu.hat_w^2 - Q*mu.hat_w^2 - 2*R*mu.hat_w +
Q*R^2 -  Q/Q.tilde*sigma.hat.sq_m)
return(a1 - (sqrt(a2)/D))
}
e1 <- with(ret, f_e1(delta = DELTA,
N = N,
D = D,
sigma.hat.sq_w = sigma.hat.sq_w,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_w = mu.hat_w,
Q = Q,
Q.tilde = Q.tilde,
R = R) )
print(e1)
#### Estimator 2 ####
f_e2 <- function(delta = DELTA,
N.tilde = N.tilde,
D.tilde = D.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_m = mu.hat_m,
Q.tilde = Q.tilde,
R.tilde = R.tilde,
Q = Q,
sigma.hat.sq_w = sigma.hat.sq_w) {
a1 <- delta + N.tilde/D.tilde
a2 <-  N.tilde^2 - 2*D.tilde * (sigma.hat.sq_m + 2*mu.hat_m^2 -
Q.tilde*mu.hat_m^2 - 2*R.tilde*mu.hat_m +
Q.tilde * R.tilde^2 - Q.tilde/Q*sigma.hat.sq_w)
return(a1 + sqrt(a2)/D.tilde)
}
e2 <- with(ret, f_e2(delta = DELTA,
N.tilde = N.tilde,
D.tilde = D.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_m = mu.hat_m,
Q.tilde = Q.tilde,
R.tilde = R.tilde,
Q = Q,
sigma.hat.sq_w = sigma.hat.sq_w))
print(e2)
f_e3 <- function(delta = DELTA,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N) {
a1 <- sigma.hat.sq_w + 2*mu.hat_w^2 - Q.tilde*mu.hat_w^2 - 2*R*mu.hat_w +
Q.tilde*R^2 - Q/Q.tilde*sigma.hat.sq_m
return(delta - a1/N)
}
e3 <- with(ret, f_e3(delta = DELTA,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N))
print(e3)
f_e4 <- function(delta = DELTA,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_m= mu.hat_m,
Q.tilde = Q.tilde,
R.tilde = R.tilde,
Q = Q,
sigma.hat.sq_w = sigma.hat.sq_w,
N.tilde = N.tilde) {
a1 <- sigma.hat.sq_m + 2*mu.hat_m^2 - Q.tilde*mu.hat_m^2 - 2*R.tilde*mu.hat_m +
Q.tilde * R.tilde^2 - Q.tilde/Q*sigma.hat.sq_w
return(delta + a1/N.tilde)
}
e4 <- with(ret, f_e4(delta = DELTA,
sigma.hat.sq_m = sigma.hat.sq_m,
mu.hat_m= mu.hat_m,
Q.tilde = Q.tilde,
R.tilde = R.tilde,
Q = Q,
sigma.hat.sq_w = sigma.hat.sq_w,
N.tilde = N.tilde))
print(e4)
n <- 10
iteration_df <- data.frame(matrix(0, n, 4))
colnames(iteration_df) <- c("e1", "e2", "e3", "e4")
# e1
iteration_df[1, "e1"] <- e1
for (i in 2:n) {
ret <- stimator(DELTA = e1, ALPHA, BETA, v_m, v_w)
e3 <- with(ret, f_e3(delta = e1,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N))
iteration_df[i, "e3"] <- e3
}
iteration_df
# e1
iteration_df[1, "e1"] <- e1
for (i in 2:n) {
ret <- stimator(DELTA = e1, ALPHA, BETA, v_m, v_w)
e1 <- with(ret, f_e3(delta = e1,
sigma.hat.sq_w = sigma.hat.sq_w,
mu.hat_w = mu.hat_w,
Q = Q,
R = R,
Q.tilde = Q.tilde,
sigma.hat.sq_m = sigma.hat.sq_m,
N=N))
iteration_df[i, "e1"] <- e1
}
